"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["describe", "test", "assert", "getUpToNextSlash", "debugKey", "repeat", "lastKeyChar", "pad", "getNextKey", "isLastKey", "getBisectKey", "middleKeyChar", "getLastKeyWithPrefix"], [global, require('../StandardImport')], (describe, test, assert, getUpToNextSlash, debugKey, repeat, lastKeyChar, pad, getNextKey, isLastKey, getBisectKey, middleKeyChar, getLastKeyWithPrefix) => {return describe({getUpToNextSlash: function() {test(":this/is/ok 0 -> :this/   ", () => assert.eq("this/", getUpToNextSlash("this/is/ok", 0))); test(":this/is/ok 4 -> :this/   ", () => assert.eq("this/", getUpToNextSlash("this/is/ok", 4))); test(":this/is/ok 5 -> :this/is/", () => assert.eq("this/is/", getUpToNextSlash("this/is/ok", 5))); test(":this/is/ok 6 -> :this/is/", () => assert.eq("this/is/", getUpToNextSlash("this/is/ok", 6))); test(":this/is/ok 7 -> :this/is/", () => assert.eq("this/is/", getUpToNextSlash("this/is/ok", 7))); test("undefined if no /", () => assert.eq(undefined, getUpToNextSlash("this", 0))); test("undefined if > last /", () => assert.eq(undefined, getUpToNextSlash("this/is/okthere", 10))); return test("undefined if > length", () => assert.eq(undefined, getUpToNextSlash("this/is/ok", 100)));}, debugKey: function() {test("debugKey :a", () => assert.match(debugKey("a"), /^a +$/)); test("debugKey ''", () => assert.match(debugKey(""), "''                  ")); return test("debugKey :ab~~~~~~~~~~~", () => assert.eq(debugKey("ab" + repeat(lastKeyChar, 10)), "ab(~*10)            "));}, getNextKey: function() {let nextKeyMap; nextKeyMap = {a: "a~", "~": "~~", [pad("b", 1023, "~")]: pad("b", 1024, "~"), [pad("b", 1024, "~")]: "c", [pad("bc", 1024, "~")]: "bd", [pad("b~c", 1024, "~")]: "b~d"}; Caf.each2(nextKeyMap, (nextKey, key) => test(`getNextKey ${Caf.toString(key)} >>> ${Caf.toString(nextKey)}`, () => assert.eq(nextKey, getNextKey(key)))); test("isLastKey (the very last key) >>> error", () => assert.true(isLastKey(pad("", 1024, "~")))); return test("getNextKey (the very last key) >>> error", () => {let lastKey; lastKey = pad("", 1024, "~"); return assert.throws(() => getNextKey(lastKey));});}, getBisectKey: {nulls_and_errors: function() {test("matching returns null", () => assert.notPresent(getBisectKey("a", "a"))); test("invalid char in first param", () => assert.rejects(() => getBisectKey("\n", "a"))); test("invalid char in second param", () => assert.rejects(() => getBisectKey("b", "ðŸ˜€"))); return test("reverse-order returns null", () => assert.notPresent(getBisectKey("b", "a")));}, basic: function() {test(":alpha :alphadude -> :b", () => assert.eq("alphaB", getBisectKey("alpha", "alphadude"))); test('"alpha" "alpha me" -> "alpha "', () => assert.eq("alpha ", getBisectKey("alpha", "alpha me"))); test('"alpha" "alpha " -> "alpha "', () => assert.eq("alpha ", getBisectKey("alpha", "alpha "))); test(":a :c -> :b", () => assert.eq("b", getBisectKey("a", "c"))); test(":alphabet :c -> :b", () => assert.eq("b", getBisectKey("alphabet", "c"))); test(":aa :ac -> :ab", () => assert.eq(`aa${Caf.toString(middleKeyChar)}`, getBisectKey("aa", "ab"))); return test("with spaces", () => assert.eq("My `", getBisectKey("My Other thing.bar", "My report.foo")));}, bisectPrefix: {dirAware: function() {return Caf.each2([["alpha/beta", "z", getLastKeyWithPrefix("alpha/")], ["alpha/beta/gamma", "alpha/boomTown", getLastKeyWithPrefix("alpha/beta/")], ["alpha/beta", "alpha/foo", "alpha/d"], ["run2/bcl-sync-status/39e8278706c47520c03865b84b06921a", "u", getLastKeyWithPrefix("run2/")]], ([a, b, out]) => test(`${Caf.toString(a)} ${Caf.toString(b)} -> ${Caf.toString(out.slice(0, 25))}${Caf.toString((out.length > 25) ? "..." : undefined)}`, () => assert.eq(out, getBisectKey(a, b, true))));}, basic: function() {test(":a :c -> :b~...", () => assert.eq("b", getBisectKey("a", "c", true))); test('"alpha" "alpha me" -> "alpha "', () => assert.eq("alpha ", getBisectKey("alpha", "alpha me", true))); test(":alpha :alphadude -> :alphaB", () => assert.eq("alphaB", getBisectKey("alpha", "alphadude", true))); test(":alphabet :c -> :alph~...", () => assert.eq("b", getBisectKey("alphabet", "c", true))); return test(":alphabet :alpi -> :alpha~...", () => assert.eq("alpho", getBisectKey("alphabet", "alpi", true)));}}, regressions: function() {test(":alpha :T -> notPresent", () => assert.notPresent(getBisectKey("alpha", "T"))); test(`:alpha :alphb -> :alpha${Caf.toString(middleKeyChar)}`, () => assert.eq(`alpha${Caf.toString(middleKeyChar)}`, getBisectKey("alpha", "alphb"))); test(":./.git/objects/17/3d216b08fff7c71eeb7bf1c7d5e8aef789461e :./.git/obk -> :./.git/objq", () => assert.eq("./.git/objq", getBisectKey("./.git/objects/17/3d216b08fff7c71eeb7bf1c7d5e8aef789461e", "./.git/obk"))); test("tildeSpecial: :2/~~ :20 -> :2/~~~", () => assert.eq("2/~~~", getBisectKey("2/~~", "20"))); test("tildeSpecial: :2/~~(+1020 more) :20999 -> :20", () => assert.eq("20", getBisectKey(pad("2/", 1024, "~"), "20999"))); test("tildeSpecial: :2/~~(+1020 more) :20 -> :20", () => assert.eq("20", getBisectKey(pad("2/", 1024, "~"), "20"))); return test("tildeSpecial: original regression", () => assert.eq("filestores/kss/20", getBisectKey("filestores/kss/2/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", "filestores/kss/20/2001-page798-2.v0.7")));}}});});});
//# sourceMappingURL=S3Keys.test.js.map
